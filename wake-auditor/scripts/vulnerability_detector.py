#!/usr/bin/env python3
"""
æ¼æ´æ£€æµ‹å™¨
åŸºäº Wake çš„è‡ªå®šä¹‰ printer è„šæœ¬ï¼Œæ£€æµ‹ç‰¹å®šçš„å®‰å…¨æ¼æ´æ¨¡å¼
"""

import ast
import re
import json
from pathlib import Path
from typing import List, Dict, Any

class VulnerabilityDetector:
    def __init__(self, project_path):
        self.project_path = Path(project_path)
        self.vulnerabilities = []

    def detect_reentrancy(self, solidity_code: str, file_path: str) -> List[Dict]:
        """æ£€æµ‹é‡å…¥æ”»å‡»æ¼æ´"""
        vulnerabilities = []

        # æ£€æµ‹æ¨¡å¼ï¼šå¤–éƒ¨è°ƒç”¨åçŠ¶æ€æ”¹å˜
        patterns = [
            r'(\w+)\.call\{value:\s*(\d+)\}\(""\)',
            r'(\w+)\.transfer\((\w+)\)',
            r'(\w+)\.send\((\w+)\)'
        ]

        lines = solidity_code.split('\n')

        for i, line in enumerate(lines, 1):
            for pattern in patterns:
                if re.search(pattern, line):
                    # æ£€æŸ¥è°ƒç”¨åæ˜¯å¦æœ‰çŠ¶æ€æ”¹å˜
                    next_lines = lines[i:i+5]  # æ£€æŸ¥åé¢5è¡Œ
                    for j, next_line in enumerate(next_lines, i+1):
                        if re.search(r'(balance|state|owner|allowance)\s*=', next_line):
                            vulnerabilities.append({
                                "type": "é‡å…¥æ”»å‡»é£é™©",
                                "severity": "é«˜",
                                "file": file_path,
                                "line": i,
                                "description": f"å¤–éƒ¨è°ƒç”¨ååœ¨ç¬¬ {j} è¡Œå‘ç°çŠ¶æ€æ”¹å˜",
                                "code_snippet": line.strip(),
                                "recommendation": "ä½¿ç”¨ Reentrancy Guard æˆ– Checks-Effects-Interactions æ¨¡å¼"
                            })
                            break

        return vulnerabilities

    def detect_access_control(self, solidity_code: str, file_path: str) -> List[Dict]:
        """æ£€æµ‹è®¿é—®æ§åˆ¶æ¼æ´"""
        vulnerabilities = []

        # æ£€æµ‹å…¬å…±å‡½æ•°ç¼ºå°‘è®¿é—®æ§åˆ¶
        lines = solidity_code.split('\n')

        for i, line in enumerate(lines, 1):
            # æŸ¥æ‰¾å‡½æ•°å®šä¹‰
            if re.search(r'function\s+\w+\s*\([^)]*\)\s*(public|external)', line):
                # æ£€æŸ¥æ˜¯å¦æœ‰ä¿®é¥°ç¬¦
                if not re.search(r'(onlyOwner|require|revert|if|when)', line):
                    # æ£€æŸ¥å‡½æ•°ä½“å‰å‡ è¡Œæ˜¯å¦æœ‰è®¿é—®æ§åˆ¶
                    func_body = lines[i:i+10]
                    has_access_control = False

                    for func_line in func_body:
                        if re.search(r'require\s*\(\s*msg\.sender', func_line):
                            has_access_control = True
                            break
                        if re.search(r'onlyOwner', func_line):
                            has_access_control = True
                            break

                    if not has_access_control:
                        vulnerabilities.append({
                            "type": "è®¿é—®æ§åˆ¶æ¼æ´",
                            "severity": "é«˜",
                            "file": file_path,
                            "line": i,
                            "description": "å…¬å…±å‡½æ•°ç¼ºå°‘è®¿é—®æ§åˆ¶",
                            "code_snippet": line.strip(),
                            "recommendation": "æ·»åŠ é€‚å½“çš„è®¿é—®æ§åˆ¶ä¿®é¥°ç¬¦æˆ– require è¯­å¥"
                        })

        return vulnerabilities

    def detect_integer_overflow(self, solidity_code: str, file_path: str) -> List[Dict]:
        """æ£€æµ‹æ•´æ•°æº¢å‡ºé£é™©"""
        vulnerabilities = []

        # æ£€æµ‹æ¨¡å¼ï¼šç®—æœ¯è¿ç®—å‰æœªæ£€æŸ¥æº¢å‡º
        risk_patterns = [
            r'(\w+)\s*\+=\s*(\w+)',
            r'(\w+)\s*-=\s*(\w+)',
            r'(\w+)\s*\*=\s*(\w+)',
            r'(\w+)\s*=\s*(\w+)\s*\+\s*(\w+)',
            r'(\w+)\s*=\s*(\w+)\s*\*\s*(\w+)'
        ]

        lines = solidity_code.split('\n')

        for i, line in enumerate(lines, 1):
            for pattern in risk_patterns:
                if re.search(pattern, line):
                    # æ£€æŸ¥å‰é¢æ˜¯å¦æœ‰æº¢å‡ºæ£€æŸ¥
                    prev_lines = lines[max(0, i-10):i]
                    has_overflow_check = False

                    for prev_line in prev_lines:
                        if re.search(r'require\s*\(\s*\w+\s*[+\-*>]\s*\w+', prev_line):
                            has_overflow_check = True
                            break
                        if re.search(r'SafeMath', prev_line):
                            has_overflow_check = True
                            break

                    if not has_overflow_check:
                        vulnerabilities.append({
                            "type": "æ•´æ•°æº¢å‡ºé£é™©",
                            "severity": "ä¸­",
                            "file": file_path,
                            "line": i,
                            "description": "ç®—æœ¯è¿ç®—å¯èƒ½å­˜åœ¨æº¢å‡ºé£é™©",
                            "code_snippet": line.strip(),
                            "recommendation": "ä½¿ç”¨ SafeMath åº“æˆ– Solidity 0.8+ å†…ç½®æº¢å‡ºæ£€æŸ¥"
                        })

        return vulnerabilities

    def detect_unchecked_call(self, solidity_code: str, file_path: str) -> List[Dict]:
        """æ£€æµ‹æœªæ£€æŸ¥çš„å¤–éƒ¨è°ƒç”¨"""
        vulnerabilities = []

        # æ£€æµ‹æ¨¡å¼ï¼šå¤–éƒ¨è°ƒç”¨è¿”å›å€¼æœªæ£€æŸ¥
        call_patterns = [
            r'(\w+)\.call\{',
            r'(\w+)\.delegatecall\(',
            r'(\w+)\.send\(',
            r'(\w+)\.transfer\('
        ]

        lines = solidity_code.split('\n')

        for i, line in enumerate(lines, 1):
            for pattern in call_patterns:
                if re.search(pattern, line):
                    # æ£€æŸ¥æ˜¯å¦æ£€æŸ¥äº†è¿”å›å€¼
                    if not re.search(r'require\s*\(', line) and not re.search(r'if\s*\(', line):
                        vulnerabilities.append({
                            "type": "æœªæ£€æŸ¥çš„å¤–éƒ¨è°ƒç”¨",
                            "severity": "ä¸­",
                            "file": file_path,
                            "line": i,
                            "description": "å¤–éƒ¨è°ƒç”¨è¿”å›å€¼æœªæ£€æŸ¥",
                            "code_snippet": line.strip(),
                            "recommendation": "æ£€æŸ¥å¤–éƒ¨è°ƒç”¨çš„è¿”å›å€¼"
                        })

        return vulnerabilities

    def analyze_contract(self, contract_path: Path):
        """åˆ†æå•ä¸ªåˆçº¦æ–‡ä»¶"""
        try:
            with open(contract_path, 'r', encoding='utf-8') as f:
                solidity_code = f.read()

            print(f"ğŸ” æ­£åœ¨åˆ†æ: {contract_path.name}")

            # è¿è¡Œå„ç§æ£€æµ‹
            all_vulnerabilities = []

            all_vulnerabilities.extend(self.detect_reentrancy(solidity_code, str(contract_path)))
            all_vulnerabilities.extend(self.detect_access_control(solidity_code, str(contract_path)))
            all_vulnerabilities.extend(self.detect_integer_overflow(solidity_code, str(contract_path)))
            all_vulnerabilities.extend(self.detect_unchecked_call(solidity_code, str(contract_path)))

            # æŒ‰ä¸¥é‡ç¨‹åº¦æ’åº
            severity_order = {"é«˜": 0, "ä¸­": 1, "ä½": 2}
            all_vulnerabilities.sort(key=lambda x: severity_order.get(x["severity"], 3))

            return all_vulnerabilities

        except Exception as e:
            print(f"âŒ åˆ†ææ–‡ä»¶ {contract_path} æ—¶å‡ºé”™: {str(e)}")
            return []

    def scan_project(self):
        """æ‰«ææ•´ä¸ªé¡¹ç›®"""
        print("ğŸš€ å¼€å§‹æ¼æ´æ£€æµ‹...")

        # æŸ¥æ‰¾æ‰€æœ‰ Solidity æ–‡ä»¶
        contracts = list(self.project_path.rglob("*.sol"))

        if not contracts:
            print("âŒ æœªæ‰¾åˆ° Solidity åˆçº¦æ–‡ä»¶")
            return

        print(f"ğŸ“ æ‰¾åˆ° {len(contracts)} ä¸ªåˆçº¦æ–‡ä»¶")

        project_vulnerabilities = {}

        for contract in contracts:
            contract_vulns = self.analyze_contract(contract)
            if contract_vulns:
                project_vulnerabilities[str(contract)] = contract_vulns

        # ç”ŸæˆæŠ¥å‘Š
        self.generate_vulnerability_report(project_vulnerabilities)

    def generate_vulnerability_report(self, vulnerabilities: Dict[str, List[Dict]]):
        """ç”Ÿæˆæ¼æ´æŠ¥å‘Š"""
        total_vulns = sum(len(vulns) for vulns in vulnerabilities.values())

        report = {
            "scan_summary": {
                "total_files": len(vulnerabilities),
                "total_vulnerabilities": total_vulns,
                "high_severity": sum(1 for vulns in vulnerabilities.values()
                                  for v in vulns if v["severity"] == "é«˜"),
                "medium_severity": sum(1 for vulns in vulnerabilities.values()
                                     for v in vulns if v["severity"] == "ä¸­"),
                "low_severity": sum(1 for vulns in vulnerabilities.values()
                                  for v in vulns if v["severity"] == "ä½")
            },
            "vulnerabilities": vulnerabilities
        }

        # ä¿å­˜æŠ¥å‘Š
        reports_dir = self.project_path / 'reports'
        reports_dir.mkdir(exist_ok=True)

        report_path = reports_dir / 'vulnerability_report.json'
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)

        print(f"\nğŸ“Š æ¼æ´æŠ¥å‘Šå·²ç”Ÿæˆ: {report_path}")

        # æ‰“å°æ‘˜è¦
        print(f"\nğŸ“ˆ æ¼æ´æ‘˜è¦:")
        print(f"   æ€»æ¼æ´æ•°: {total_vulns}")
        print(f"   é«˜å±æ¼æ´: {report['scan_summary']['high_severity']}")
        print(f"   ä¸­å±æ¼æ´: {report['scan_summary']['medium_severity']}")
        print(f"   ä½å±æ¼æ´: {report['scan_summary']['low_severity']}")

        # æ‰“å°é«˜å±æ¼æ´è¯¦æƒ…
        if report['scan_summary']['high_severity'] > 0:
            print(f"\nâš ï¸  é«˜å±æ¼æ´è¯¦æƒ…:")
            for file_path, vulns in vulnerabilities.items():
                for vuln in vulns:
                    if vuln["severity"] == "é«˜":
                        print(f"   ğŸ“ {file_path}:{vuln['line']} - {vuln['type']}")

def main():
    import argparse

    parser = argparse.ArgumentParser(description='æ™ºèƒ½åˆçº¦æ¼æ´æ£€æµ‹å™¨')
    parser.add_argument('--path', default='.', help='é¡¹ç›®è·¯å¾„ (é»˜è®¤: å½“å‰ç›®å½•)')

    args = parser.parse_args()

    detector = VulnerabilityDetector(args.path)
    detector.scan_project()

if __name__ == "__main__":
    main()